<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced SVG Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
    <style>
        /* Reset and Base Styles */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Arial', sans-serif;
            background: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        header {
            background: #34495e;
            padding: 15px 30px;
            border-bottom: 2px solid #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        header h1 { font-size: 1.8rem; color: #f39c12; }
        header .header-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        header .header-buttons button {
            background: #34495e;
            border: none;
            color: #ecf0f1;
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 5px;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1rem;
        }
        header .header-buttons button:hover {
            background: #2980b9;
        }
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        /* Sidebar Styles */
        #sidebar {
            width: 300px;
            background: #2c3e50;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        /* Toolbar Styles */
        #toolbar {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
        }
        #toolbar button {
            padding: 10px;
            background: #34495e;
            border: none;
            color: #ecf0f1;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
        }
        #toolbar button:hover, #toolbar button.active {
            background: #2980b9;
        }
        /* Properties Panel */
        #properties-panel {
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #properties-panel h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #f39c12;
        }
        #properties-panel .property {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #properties-panel .color-picker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
            cursor: pointer;
            background-color: #000000;
        }
        #properties-panel input[type="color"] {
            display: none;
        }
        #properties-panel .slider {
            flex: 1;
        }
        /* Canvas Container */
        #canvas-container {
            flex: 1;
            background: #34495e;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container.grabbing {
            cursor: grabbing;
        }
        svg { 
            background-color: #ecf0f1; 
            border-radius: 12px; 
            width: 100%;
            height: 100%;
            user-select: none;
            cursor: default;
        }
        /* Layers Panel */
        #layers-panel {
            width: 300px;
            background: #2c3e50;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        #layers-panel h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #f39c12;
        }
        #layers-list {
            flex: 1;
            overflow-y: auto;
        }
        .layer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #3d566e;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        .layer.active {
            background: #2980b9;
        }
        .layer .layer-controls {
            display: flex;
            gap: 5px;
        }
        .layer .layer-controls button {
            background: transparent;
            border: none;
            color: #ecf0f1;
            cursor: pointer;
            font-size: 0.9rem;
        }
        #add-layer {
            background: #27ae60;
            color: #fff;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            margin-top: 10px;
        }
        #add-layer:hover {
            background: #2ecc71;
        }
        /* Context Menu */
        #context-menu {
            position: absolute;
            background: #34495e;
            border: 1px solid #2c3e50;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            min-width: 150px;
        }
        #context-menu ul {
            list-style: none;
        }
        #context-menu ul li {
            padding: 10px;
            cursor: pointer;
            color: #ecf0f1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #context-menu ul li:hover {
            background: #2980b9;
        }
        /* Zoom Slider Styles - Moved to Bottom Right */
        .zoom-slider {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(52, 73, 94, 0.8);
            padding: 10px;
            border-radius: 8px;
        }
        .zoom-slider input[type="range"] {
            width: 100px;
        }
        .zoom-slider i {
            font-size: 1.2rem;
            color: #ecf0f1;
        }
        /* Responsive Adjustments */
        @media (max-width: 1200px) {
            #sidebar, #layers-panel {
                width: 250px;
            }
        }
        @media (max-width: 992px) {
            #sidebar, #layers-panel {
                width: 200px;
            }
            header h1 { font-size: 1.5rem; }
        }
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 10px;
            }
            main {
                flex-direction: column;
            }
            #sidebar, #layers-panel {
                width: 100%;
                height: 200px;
            }
            #canvas-container {
                height: calc(100vh - 300px);
            }
            .zoom-slider {
                position: absolute;
                bottom: 10px;
                right: 10px;
            }
        }
        /* Transform Box Styles */
        .transform-box {
            stroke: #f39c12;
            stroke-width: 1;
            fill: none;
            pointer-events: none;
        }
        .transform-handle {
            fill: #2980b9;
            stroke: #fff;
            stroke-width: 1;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <header>
        <h1>Advanced SVG Editor</h1>
        <div class="header-buttons">
            <button id="undoBtn" title="Undo (Ctrl + Z)"><i class="fas fa-undo"></i> Undo</button>
            <button id="redoBtn" title="Redo (Ctrl + Y)"><i class="fas fa-redo"></i> Redo</button>
            <button id="downloadBtn" title="Download SVG"><i class="fas fa-download"></i> Download</button>
            <button id="uploadBtn" title="Upload SVG"><i class="fas fa-upload"></i> Upload</button>
            <input type="file" id="uploadInput" accept=".svg" style="display: none;">
        </div>
    </header>
    <main>
        <!-- Sidebar with toolbar and properties -->
        <aside id="sidebar">
            <!-- Toolbar -->
            <div id="toolbar">
                <button id="selectTool" class="active"><i class="fas fa-mouse-pointer"></i> Select</button>
                <button id="drawTool"><i class="fas fa-pencil-alt"></i> Pen</button>
                <button id="brushTool"><i class="fas fa-brush"></i> Brush</button> <!-- New Brush Tool -->
                <button id="paintBucketTool"><i class="fas fa-fill-drip"></i> Paint Bucket</button> <!-- New Paint Bucket Tool -->
                <button id="rectangleTool"><i class="fas fa-square"></i> Rectangle</button>
                <button id="circleTool"><i class="fas fa-circle"></i> Circle</button>
                <button id="ellipseTool"><i class="fas fa-ellipse"></i> Ellipse</button>
                <button id="lineTool"><i class="fas fa-slash"></i> Line</button>
                <button id="polygonTool"><i class="fas fa-draw-polygon"></i> Polygon</button>
                <button id="textTool"><i class="fas fa-font"></i> Text</button>
                <button id="imageTool"><i class="fas fa-image"></i> Image</button>
            </div>
            <!-- Properties Panel -->
            <div id="properties-panel">
                <h2>Properties</h2>
                <div class="property">
                    <div class="color-picker" id="colorDisplay"></div>
                    <input type="color" id="colorPicker" value="#000000">
                </div>
                <div class="property">
                    <label for="sizeSlider">Size:</label>
                    <input type="range" id="sizeSlider" class="slider" min="1" max="20" value="2">
                </div>
                <div class="property">
                    <label for="opacitySlider">Opacity:</label>
                    <input type="range" id="opacitySlider" class="slider" min="0" max="1" step="0.1" value="1">
                </div>
            </div>
        </aside>
        <!-- Canvas Container -->
        <section id="canvas-container">
            <svg id="canvas" width="10000" height="10000" viewBox="0 0 1600 1200"></svg>
            <!-- Context Menu -->
            <div id="context-menu">
                <ul>
                    <li id="context-delete"><i class="fas fa-trash-alt"></i> Delete</li>
                </ul>
            </div>
            <!-- Zoom Slider at Bottom Right -->
            <div class="zoom-slider">
                <i class="fas fa-search-minus"></i> <!-- Zoom Out Icon -->
                <input type="range" id="zoomSlider" min="10" max="500" value="100">
                <i class="fas fa-search-plus"></i> <!-- Zoom In Icon -->
            </div>
        </section>
        <!-- Layers Panel -->
        <aside id="layers-panel">
            <h2>Layers</h2>
            <div id="layers-list"></div>
            <button id="add-layer"><i class="fas fa-plus"></i> Add Layer</button>
        </aside>
    </main>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const canvas = document.getElementById('canvas');
        const colorDisplay = document.getElementById('colorDisplay');
        const colorPicker = document.getElementById('colorPicker');
        const sizeSlider = document.getElementById('sizeSlider');
        const opacitySlider = document.getElementById('opacitySlider');
        const layersList = document.getElementById('layers-list');
        const addLayerButton = document.getElementById('add-layer');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadInput = document.getElementById('uploadInput');
        const contextMenu = document.getElementById('context-menu');
        const contextDelete = document.getElementById('context-delete');
        const zoomSlider = document.getElementById('zoomSlider');
        const canvasContainer = document.getElementById('canvas-container');

        let activeTool = 'select';
        let currentElement = null;
        let drawPath = null;
        let isDrawing = false;
        let selectedElements = [];
        let layers = [];
        let currentLayer = null;

        // Undo/Redo stacks
        let undoStack = [];
        let redoStack = [];

        // Zoom and Pan parameters
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;

        // Transform box
        let transformBox = null;
        let transformHandles = {};

        // Clipboard for copy-paste
        let clipboard = null;

        // Initialize with a default layer
        addLayer('Layer 1');

        // Tool activation
        document.getElementById('selectTool').addEventListener('click', () => activateTool('select'));
        document.getElementById('drawTool').addEventListener('click', () => activateTool('draw'));
        document.getElementById('brushTool').addEventListener('click', () => activateTool('brush')); // Brush Tool
        document.getElementById('paintBucketTool').addEventListener('click', () => activateTool('paintBucket')); // Paint Bucket Tool
        document.getElementById('rectangleTool').addEventListener('click', () => activateTool('rectangle'));
        document.getElementById('circleTool').addEventListener('click', () => activateTool('circle'));
        document.getElementById('ellipseTool').addEventListener('click', () => activateTool('ellipse'));
        document.getElementById('lineTool').addEventListener('click', () => activateTool('line'));
        document.getElementById('polygonTool').addEventListener('click', () => activateTool('polygon'));
        document.getElementById('textTool').addEventListener('click', () => activateTool('text'));
        document.getElementById('imageTool').addEventListener('click', () => activateTool('image'));
        addLayerButton.addEventListener('click', () => {
            const layerName = prompt("Enter layer name:", `Layer ${layers.length + 1}`);
            if (layerName) {
                addLayer(layerName);
            }
        });

        // Activate tool and update toolbar UI
        function activateTool(tool) {
            activeTool = tool;
            currentElement = null;
            drawPath = null;
            if (tool !== 'select') {
                deselectAll();
            }
            updateActiveToolButton(tool);
        }

        // Update toolbar button styles based on active tool
        function updateActiveToolButton(tool) {
            const toolButtons = document.querySelectorAll('#toolbar button');
            toolButtons.forEach(button => {
                if (button.id.replace('Tool', '').toLowerCase() === tool) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // Layer management
        function addLayer(name) {
            const layer = document.createElementNS(svgNS, 'g');
            layer.setAttribute('data-layer', name);
            layer.setAttribute('data-visible', 'true');
            canvas.appendChild(layer);
            layers.push(layer);
            currentLayer = layer;
            updateLayersPanel();
            pushToUndoStack();
        }

        function updateLayersPanel() {
            layersList.innerHTML = '';
            layers.slice().reverse().forEach((layer, index) => {
                const layerDiv = document.createElement('div');
                layerDiv.classList.add('layer');
                if (layer === currentLayer) {
                    layerDiv.classList.add('active');
                }
                layerDiv.innerHTML = `
                    <span>${layer.getAttribute('data-layer')}</span>
                    <div class="layer-controls">
                        <button class="visibility-toggle" title="Toggle Visibility"><i class="fas fa-eye"></i></button>
                        <button class="delete-layer" title="Delete Layer"><i class="fas fa-trash-alt"></i></button>
                    </div>
                `;
                layerDiv.addEventListener('click', (e) => {
                    if (e.target.closest('.layer-controls')) return;
                    currentLayer = layer;
                    updateLayersPanel();
                });
                // Visibility toggle
                layerDiv.querySelector('.visibility-toggle').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = layer.getAttribute('data-visible') === 'true';
                    layer.setAttribute('data-visible', isVisible ? 'false' : 'true');
                    layer.style.display = isVisible ? 'none' : 'block';
                    e.target.innerHTML = isVisible ? '<i class="fas fa-eye-slash"></i>' : '<i class="fas fa-eye"></i>';
                    pushToUndoStack();
                });
                // Delete layer
                layerDiv.querySelector('.delete-layer').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (layers.length === 1) {
                        alert("Cannot delete the only layer.");
                        return;
                    }
                    canvas.removeChild(layer);
                    layers = layers.filter(l => l !== layer);
                    currentLayer = layers[layers.length - 1];
                    updateLayersPanel();
                    pushToUndoStack();
                });
                layersList.appendChild(layerDiv);
            });
        }

        // SVG drawing based on active tool
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', continueDrawing);
        canvas.addEventListener('mouseup', finishDrawing);
        canvas.addEventListener('click', selectElement);

        function startDrawing(e) {
            if (activeTool === 'select' || activeTool === 'paintBucket') return;
            isDrawing = true;
            const pt = getMousePosition(e);
            const x = pt.x;
            const y = pt.y;

            if (activeTool === 'draw') {
                drawPath = createSVGElement('path', {
                    d: `M${x},${y}`,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    fill: 'none',
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(drawPath);
            } else if (activeTool === 'brush') { // Brush Tool
                drawPath = createSVGElement('path', {
                    d: `M${x},${y}`,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    fill: 'none',
                    'stroke-linecap': 'round',
                    'stroke-linejoin': 'round',
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(drawPath);
            } else if (activeTool === 'rectangle') {
                currentElement = createSVGElement('rect', {
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    fill: colorPicker.value,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    'fill-opacity': opacitySlider.value,
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(currentElement);
            } else if (activeTool === 'circle') {
                currentElement = createSVGElement('circle', {
                    cx: x,
                    cy: y,
                    r: 0,
                    fill: colorPicker.value,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    'fill-opacity': opacitySlider.value,
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(currentElement);
            } else if (activeTool === 'ellipse') {
                currentElement = createSVGElement('ellipse', {
                    cx: x,
                    cy: y,
                    rx: 0,
                    ry: 0,
                    fill: colorPicker.value,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    'fill-opacity': opacitySlider.value,
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(currentElement);
            } else if (activeTool === 'line') {
                currentElement = createSVGElement('line', {
                    x1: x,
                    y1: y,
                    x2: x,
                    y2: y,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(currentElement);
            } else if (activeTool === 'polygon') {
                currentElement = createSVGElement('polygon', {
                    points: `${x},${y} ${x},${y} ${x},${y}`,
                    fill: colorPicker.value,
                    stroke: colorPicker.value,
                    'stroke-width': sizeSlider.value,
                    'fill-opacity': opacitySlider.value,
                    'stroke-opacity': opacitySlider.value
                });
                currentLayer.appendChild(currentElement);
            } else if (activeTool === 'text') {
                const text = prompt("Enter text:");
                if (text) {
                    const textElement = createSVGElement('text', {
                        x: x,
                        y: y,
                        fill: colorPicker.value,
                        'font-size': sizeSlider.value * 4,
                        'fill-opacity': opacitySlider.value,
                        'cursor': 'move'
                    });
                    textElement.textContent = text;
                    makeDraggable(textElement);
                    currentLayer.appendChild(textElement);
                    selectElementByElement(textElement);
                    pushToUndoStack();
                }
            } else if (activeTool === 'image') {
                const imageUrl = prompt("Enter image URL:");
                if (imageUrl) {
                    const img = createSVGElement('image', {
                        href: imageUrl,
                        x: x,
                        y: y,
                        width: 100,
                        height: 100,
                        'cursor': 'move'
                    });
                    makeDraggable(img);
                    currentLayer.appendChild(img);
                    selectElementByElement(img);
                    pushToUndoStack();
                }
            }
        }

        function continueDrawing(e) {
            if (!isDrawing) return;
            const pt = getMousePosition(e);
            const x = pt.x;
            const y = pt.y;

            if (activeTool === 'draw' && drawPath) {
                drawPath.setAttribute("d", `${drawPath.getAttribute("d")} L${x},${y}`);
            } else if (activeTool === 'brush' && drawPath) { // Brush Tool
                drawPath.setAttribute("d", `${drawPath.getAttribute("d")} L${x},${y}`);
            } else if (currentElement) {
                if (activeTool === 'rectangle' || activeTool === 'brush') {
                    const startX = parseFloat(currentElement.getAttribute('x'));
                    const startY = parseFloat(currentElement.getAttribute('y'));
                    let width = x - startX;
                    let height = y - startY;
                    
                    // Flip logic: If width or height is negative, flip the object
                    if (width < 0) {
                        currentElement.setAttribute('x', x);
                        width = Math.abs(width);
                    }
                    if (height < 0) {
                        currentElement.setAttribute('y', y);
                        height = Math.abs(height);
                    }

                    currentElement.setAttribute('width', width);
                    currentElement.setAttribute('height', height);
                } else if (activeTool === 'circle') {
                    const cx = parseFloat(currentElement.getAttribute('cx'));
                    const cy = parseFloat(currentElement.getAttribute('cy'));
                    let radius = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
                    currentElement.setAttribute('r', radius);
                } else if (activeTool === 'ellipse') {
                    const cx = parseFloat(currentElement.getAttribute('cx'));
                    const cy = parseFloat(currentElement.getAttribute('cy'));
                    let rx = Math.abs(x - cx);
                    let ry = Math.abs(y - cy);
                    currentElement.setAttribute('rx', rx);
                    currentElement.setAttribute('ry', ry);
                } else if (activeTool === 'line') {
                    currentElement.setAttribute('x2', x);
                    currentElement.setAttribute('y2', y);
                } else if (activeTool === 'polygon') {
                    const points = currentElement.getAttribute('points').split(' ');
                    if (points.length < 3) {
                        currentElement.setAttribute('points', `${points[0]} ${x},${y} ${x},${y}`);
                    } else {
                        const firstPoint = points[0];
                        currentElement.setAttribute('points', `${firstPoint} ${x},${y} ${x},${y}`);
                    }
                }
            }
        }

        function finishDrawing() {
            if (isDrawing) {
                pushToUndoStack();
            }
            isDrawing = false;
            drawPath = null;
            currentElement = null;
        }

        // Utility to get mouse position relative to SVG
        function getMousePosition(evt) {
            const CTM = canvas.getScreenCTM();
            return {
                x: (evt.clientX - CTM.e) / CTM.a,
                y: (evt.clientY - CTM.f) / CTM.d
            };
        }

        // Utility to create SVG elements
        function createSVGElement(type, attributes) {
            const element = document.createElementNS(svgNS, type);
            for (let key in attributes) {
                element.setAttribute(key, attributes[key]);
            }
            if (type !== 'g' && type !== 'path') {
                makeDraggable(element);
            }
            return element;
        }

        // Make SVG elements draggable
        function makeDraggable(element) {
            element.addEventListener('mousedown', (e) => {
                if (activeTool !== 'select') return;
                e.stopPropagation();
                if (!e.ctrlKey && !e.metaKey) {
                    if (!selectedElements.includes(element)) {
                        deselectAll();
                        selectElementByElement(element);
                    }
                }
                const pt = getMousePosition(e);
                const startX = pt.x;
                const startY = pt.y;

                let origX = 0, origY = 0;
                if (element.tagName === 'rect' || element.tagName === 'text' || element.tagName === 'image') {
                    origX = parseFloat(element.getAttribute('x')) || 0;
                    origY = parseFloat(element.getAttribute('y')) || 0;
                } else if (element.tagName === 'circle' || element.tagName === 'ellipse') {
                    origX = parseFloat(element.getAttribute('cx')) || 0;
                    origY = parseFloat(element.getAttribute('cy')) || 0;
                } else if (element.tagName === 'line') {
                    origX = parseFloat(element.getAttribute('x1')) || 0;
                    origY = parseFloat(element.getAttribute('y1')) || 0;
                } else if (element.tagName === 'polygon') {
                    // Handle polygons separately if needed
                }

                function onMouseMove(event) {
                    const ptMove = getMousePosition(event);
                    const dx = ptMove.x - startX;
                    const dy = ptMove.y - startY;
                    
                    // Update position based on mouse movement
                    if (element.tagName === 'rect' || element.tagName === 'text' || element.tagName === 'image') {
                        element.setAttribute('x', origX + dx);
                        element.setAttribute('y', origY + dy);
                    } else if (element.tagName === 'circle' || element.tagName === 'ellipse') {
                        element.setAttribute('cx', origX + dx);
                        element.setAttribute('cy', origY + dy);
                    } else if (element.tagName === 'line') {
                        element.setAttribute('x1', origX + dx);
                        element.setAttribute('y1', origY + dy);
                        element.setAttribute('x2', origX + dx + 50); // Maintain a fixed length
                        element.setAttribute('y2', origY + dy + 50);
                    } else if (element.tagName === 'polygon') {
                        // Implement polygon dragging if needed
                    }

                    updateTransformBox(element);
                }

                function onMouseUp() {
                    canvas.removeEventListener('mousemove', onMouseMove);
                    canvas.removeEventListener('mouseup', onMouseUp);
                    pushToUndoStack();
                }

                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
            });
        }

        // Selection functionality
        function selectElement(e) {
            if (activeTool !== 'select') return;
            const target = e.target;
            if (target === canvas) {
                if (!e.ctrlKey && !e.metaKey) {
                    deselectAll();
                }
                removeTransformBox();
                return;
            }
            if (e.ctrlKey || e.metaKey) {
                if (selectedElements.includes(target)) {
                    selectedElements = selectedElements.filter(el => el !== target);
                    removeSelectionStyle(target);
                } else {
                    selectedElements.push(target);
                    applySelectionStyle(target);
                }
            } else {
                if (!selectedElements.includes(target)) {
                    deselectAll();
                    selectedElements.push(target);
                    applySelectionStyle(target);
                }
            }
            if (selectedElements.length === 1) {
                createTransformBox(selectedElements[0]);
            } else {
                removeTransformBox();
            }
            updatePropertiesPanel();
        }

        function selectElementByElement(element) {
            selectedElements.push(element);
            applySelectionStyle(element);
            createTransformBox(element);
            updatePropertiesPanel();
        }

        function deselectAll() {
            selectedElements.forEach(el => {
                removeSelectionStyle(el);
            });
            selectedElements = [];
            removeTransformBox();
            updatePropertiesPanel();
        }

        function applySelectionStyle(element) {
            element.setAttribute('stroke', '#f39c12');
            element.setAttribute('stroke-width', 2);
        }

        function removeSelectionStyle(element) {
            if (element.tagName === 'text' || element.tagName === 'image') {
                element.removeAttribute('stroke');
                element.removeAttribute('stroke-width');
            } else {
                element.removeAttribute('stroke');
                element.removeAttribute('stroke-width');
            }
        }

        // Update properties panel based on selection
        function updatePropertiesPanel() {
            if (selectedElements.length === 1) {
                const el = selectedElements[0];
                colorDisplay.style.backgroundColor = rgbToHex(el.getAttribute('fill') || el.getAttribute('stroke') || '#000000');
                colorPicker.value = rgbToHex(el.getAttribute('fill') || el.getAttribute('stroke') || '#000000');
                sizeSlider.value = el.getAttribute('stroke-width') || 1;
                opacitySlider.value = el.getAttribute('fill-opacity') || el.getAttribute('stroke-opacity') || 1;
            } else if (selectedElements.length > 1) {
                colorDisplay.style.backgroundColor = '#000000';
                colorPicker.value = '#000000';
                sizeSlider.value = 2;
                opacitySlider.value = 1;
            } else {
                colorDisplay.style.backgroundColor = '#000000';
                colorPicker.value = '#000000';
                sizeSlider.value = 2;
                opacitySlider.value = 1;
            }
        }

        // Change properties of selected elements
        colorDisplay.addEventListener('click', () => {
            colorPicker.click();
        });

        colorPicker.addEventListener('input', () => {
            colorDisplay.style.backgroundColor = colorPicker.value;
            selectedElements.forEach(el => {
                if (activeTool === 'paintBucket') return; // Avoid interference with paint bucket
                if (el.tagName === 'text' || el.tagName === 'image') {
                    el.setAttribute('fill', colorPicker.value);
                } else {
                    el.setAttribute('stroke', colorPicker.value);
                    el.setAttribute('fill', colorPicker.value);
                }
            });
            pushToUndoStack();
        });

        sizeSlider.addEventListener('input', () => {
            selectedElements.forEach(el => {
                el.setAttribute('stroke-width', sizeSlider.value);
                if (el.tagName === 'text') {
                    el.setAttribute('font-size', sizeSlider.value * 4);
                }
            });
            pushToUndoStack();
        });

        opacitySlider.addEventListener('input', () => {
            selectedElements.forEach(el => {
                if (el.hasAttribute('fill')) {
                    el.setAttribute('fill-opacity', opacitySlider.value);
                }
                if (el.hasAttribute('stroke')) {
                    el.setAttribute('stroke-opacity', opacitySlider.value);
                }
            });
            pushToUndoStack();
        });

        // Context Menu functionality
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const pt = getMousePosition(e);
            contextMenu.style.top = `${pt.y}px`;
            contextMenu.style.left = `${pt.x}px`;
            contextMenu.style.display = 'block';
        });

        window.addEventListener('click', () => {
            contextMenu.style.display = 'none';
        });

        contextDelete.addEventListener('click', () => {
            if (selectedElements.length === 0) return;
            selectedElements.forEach(el => {
                const parent = el.parentNode;
                parent.removeChild(el);
            });
            selectedElements = [];
            updatePropertiesPanel();
            removeTransformBox();
            contextMenu.style.display = 'none';
            pushToUndoStack();
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copyElements();
            } else if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                pasteElements();
            } else if (e.ctrlKey && e.key === 'x') {
                e.preventDefault();
                cutElements();
            } else if (e.key === 'Delete') {
                e.preventDefault();
                deleteSelectedElements();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                if (selectedElements.length === 0) return;
                e.preventDefault();
                const step = e.shiftKey ? 10 : 1;
                selectedElements.forEach(el => {
                    if (el.tagName === 'rect' || el.tagName === 'text' || el.tagName === 'image') {
                        let x = parseFloat(el.getAttribute('x')) || 0;
                        let y = parseFloat(el.getAttribute('y')) || 0;
                        if (e.key === 'ArrowUp') y -= step;
                        if (e.key === 'ArrowDown') y += step;
                        if (e.key === 'ArrowLeft') x -= step;
                        if (e.key === 'ArrowRight') x += step;
                        el.setAttribute('x', x);
                        el.setAttribute('y', y);
                    } else if (el.tagName === 'circle' || el.tagName === 'ellipse') {
                        let cx = parseFloat(el.getAttribute('cx')) || 0;
                        let cy = parseFloat(el.getAttribute('cy')) || 0;
                        if (e.key === 'ArrowUp') cy -= step;
                        if (e.key === 'ArrowDown') cy += step;
                        if (e.key === 'ArrowLeft') cx -= step;
                        if (e.key === 'ArrowRight') cx += step;
                        el.setAttribute('cx', cx);
                        el.setAttribute('cy', cy);
                    } else if (el.tagName === 'line') {
                        let x1 = parseFloat(el.getAttribute('x1')) || 0;
                        let y1 = parseFloat(el.getAttribute('y1')) || 0;
                        let x2 = parseFloat(el.getAttribute('x2')) || 0;
                        let y2 = parseFloat(el.getAttribute('y2')) || 0;
                        if (e.key === 'ArrowUp') { y1 -= step; y2 -= step; }
                        if (e.key === 'ArrowDown') { y1 += step; y2 += step; }
                        if (e.key === 'ArrowLeft') { x1 -= step; x2 -= step; }
                        if (e.key === 'ArrowRight') { x1 += step; x2 += step; }
                        el.setAttribute('x1', x1);
                        el.setAttribute('y1', y1);
                        el.setAttribute('x2', x2);
                        el.setAttribute('y2', y2);
                    } else if (el.tagName === 'polygon') {
                        const points = el.getAttribute('points').split(' ').map(point => {
                            let [px, py] = point.split(',').map(Number);
                            if (e.key === 'ArrowUp') py -= step;
                            if (e.key === 'ArrowDown') py += step;
                            if (e.key === 'ArrowLeft') px -= step;
                            if (e.key === 'ArrowRight') px += step;
                            return `${px},${py}`;
                        }).join(' ');
                        el.setAttribute('points', points);
                    }
                });
                pushToUndoStack();
            }
        });

        // Copy, Paste, Cut Functionality
        function copyElements() {
            if (selectedElements.length === 0) return;
            clipboard = selectedElements.map(el => el.cloneNode(true));
        }

        function pasteElements() {
            if (!clipboard) return;
            deselectAll();
            clipboard.forEach(el => {
                const importedNode = document.importNode(el, true);
                // Offset pasted elements slightly
                if (importedNode.tagName === 'rect' || importedNode.tagName === 'text' || importedNode.tagName === 'image') {
                    let x = parseFloat(importedNode.getAttribute('x')) || 0;
                    let y = parseFloat(importedNode.getAttribute('y')) || 0;
                    importedNode.setAttribute('x', x + 10);
                    importedNode.setAttribute('y', y + 10);
                } else if (importedNode.tagName === 'circle' || importedNode.tagName === 'ellipse') {
                    let cx = parseFloat(importedNode.getAttribute('cx')) || 0;
                    let cy = parseFloat(importedNode.getAttribute('cy')) || 0;
                    importedNode.setAttribute('cx', cx + 10);
                    importedNode.setAttribute('cy', cy + 10);
                } else if (importedNode.tagName === 'line') {
                    let x1 = parseFloat(importedNode.getAttribute('x1')) || 0;
                    let y1 = parseFloat(importedNode.getAttribute('y1')) || 0;
                    let x2 = parseFloat(importedNode.getAttribute('x2')) || 0;
                    let y2 = parseFloat(importedNode.getAttribute('y2')) || 0;
                    importedNode.setAttribute('x1', x1 + 10);
                    importedNode.setAttribute('y1', y1 + 10);
                    importedNode.setAttribute('x2', x2 + 10);
                    importedNode.setAttribute('y2', y2 + 10);
                } else if (importedNode.tagName === 'polygon') {
                    const points = importedNode.getAttribute('points').split(' ').map(point => {
                        let [px, py] = point.split(',').map(Number);
                        return `${px + 10},${py + 10}`;
                    }).join(' ');
                    importedNode.setAttribute('points', points);
                }
                currentLayer.appendChild(importedNode);
                makeDraggable(importedNode);
                selectedElements.push(importedNode);
                applySelectionStyle(importedNode);
                createTransformBox(importedNode);
            });
            updatePropertiesPanel();
            pushToUndoStack();
        }

        function cutElements() {
            if (selectedElements.length === 0) return;
            copyElements();
            selectedElements.forEach(el => {
                const parent = el.parentNode;
                parent.removeChild(el);
            });
            selectedElements = [];
            removeTransformBox();
            updatePropertiesPanel();
            pushToUndoStack();
        }

        // Delete selected elements
        function deleteSelectedElements() {
            if (selectedElements.length === 0) return;
            selectedElements.forEach(el => {
                const parent = el.parentNode;
                parent.removeChild(el);
            });
            selectedElements = [];
            removeTransformBox();
            updatePropertiesPanel();
            pushToUndoStack();
        }

        // Transform Box Functions
        function createTransformBox(element) {
            removeTransformBox(); // Remove existing if any
            const bbox = element.getBBox();
            const box = createSVGElement('rect', {
                x: bbox.x - 10,
                y: bbox.y - 10,
                width: bbox.width + 20,
                height: bbox.height + 20,
                class: 'transform-box'
            });
            canvas.appendChild(box);
            transformBox = box;

            // Create handles
            const handles = {
                nw: createSVGElement('circle', { cx: bbox.x - 10, cy: bbox.y - 10, r: 5, class: 'transform-handle', cursor: 'nwse-resize' }),
                ne: createSVGElement('circle', { cx: bbox.x + bbox.width + 10, cy: bbox.y - 10, r: 5, class: 'transform-handle', cursor: 'nesw-resize' }),
                sw: createSVGElement('circle', { cx: bbox.x - 10, cy: bbox.y + bbox.height + 10, r: 5, class: 'transform-handle', cursor: 'nesw-resize' }),
                se: createSVGElement('circle', { cx: bbox.x + bbox.width + 10, cy: bbox.y + bbox.height + 10, r: 5, class: 'transform-handle', cursor: 'nwse-resize' }),
                rotate: createSVGElement('circle', { cx: bbox.x + bbox.width / 2, cy: bbox.y - 30, r: 5, class: 'transform-handle', cursor: 'grab' })
            };

            for (let key in handles) {
                canvas.appendChild(handles[key]);
                transformHandles[key] = handles[key];
                addTransformHandleEvents(handles[key], key, element);
            }
        }

        function removeTransformBox() {
            if (transformBox) {
                canvas.removeChild(transformBox);
                transformBox = null;
            }
            for (let key in transformHandles) {
                canvas.removeChild(transformHandles[key]);
                delete transformHandles[key];
            }
        }

        // Add Transform Handle Events
        function addTransformHandleEvents(handle, type, element) {
            let isDragging = false;
            let startX, startY;
            let origX, origY, origWidth, origHeight, origCx, origCy, origRotation, origPoints;

            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isDragging = true;
                const pt = getMousePosition(e);
                startX = pt.x;
                startY = pt.y;

                if (element.tagName === 'rect') {
                    origX = parseFloat(element.getAttribute('x'));
                    origY = parseFloat(element.getAttribute('y'));
                    origWidth = parseFloat(element.getAttribute('width'));
                    origHeight = parseFloat(element.getAttribute('height'));
                } else if (element.tagName === 'circle') {
                    origCx = parseFloat(element.getAttribute('cx'));
                    origCy = parseFloat(element.getAttribute('cy'));
                    origRotation = getRotation(element);
                } else if (element.tagName === 'ellipse') {
                    origCx = parseFloat(element.getAttribute('cx'));
                    origCy = parseFloat(element.getAttribute('cy'));
                    origRx = parseFloat(element.getAttribute('rx'));
                    origRy = parseFloat(element.getAttribute('ry'));
                } else if (element.tagName === 'line') {
                    origX1 = parseFloat(element.getAttribute('x1'));
                    origY1 = parseFloat(element.getAttribute('y1'));
                    origX2 = parseFloat(element.getAttribute('x2'));
                    origY2 = parseFloat(element.getAttribute('y2'));
                } else if (element.tagName === 'polygon') {
                    origPoints = element.getAttribute('points').split(' ').map(point => point.split(',').map(Number));
                }

                function onMouseMove(event) {
                    if (!isDragging) return;
                    const ptMove = getMousePosition(event);
                    const dx = ptMove.x - startX;
                    const dy = ptMove.y - startY;

                    if (type === 'nw' || type === 'ne' || type === 'sw' || type === 'se') {
                        if (element.tagName === 'rect') {
                            let newX = origX;
                            let newY = origY;
                            let newWidth = origWidth;
                            let newHeight = origHeight;

                            if (type === 'nw') {
                                newX = origX + dx;
                                newY = origY + dy;
                                newWidth = origWidth - dx;
                                newHeight = origHeight - dy;
                            } else if (type === 'ne') {
                                newY = origY + dy;
                                newWidth = origWidth + dx;
                                newHeight = origHeight - dy;
                            } else if (type === 'sw') {
                                newX = origX + dx;
                                newWidth = origWidth - dx;
                                newHeight = origHeight + dy;
                            } else if (type === 'se') {
                                newWidth = origWidth + dx;
                                newHeight = origHeight + dy;
                            }

                            // Flip logic: If width or height is negative, flip the object and adjust
                            if (newWidth < 0) {
                                newWidth = Math.abs(newWidth);
                                newX -= newWidth;
                            }
                            if (newHeight < 0) {
                                newHeight = Math.abs(newHeight);
                                newY -= newHeight;
                            }

                            element.setAttribute('x', newX);
                            element.setAttribute('y', newY);
                            element.setAttribute('width', newWidth);
                            element.setAttribute('height', newHeight);
                        }
                        // Add similar handling for other shapes if needed
                    } else if (type === 'rotate') {
                        if (element.tagName === 'rect' || element.tagName === 'circle' || element.tagName === 'ellipse') {
                            const centerX = element.tagName === 'rect' ? (origX + origWidth / 2) : origCx;
                            const centerY = element.tagName === 'rect' ? (origY + origHeight / 2) : origCy;
                            const angle = Math.atan2(ptMove.y - centerY, ptMove.x - centerX) * (180 / Math.PI);
                            element.setAttribute('transform', `rotate(${angle}, ${centerX}, ${centerY})`);
                        }
                    }

                    updateTransformBox(element);
                }

                function onMouseUp() {
                    if (isDragging) {
                        isDragging = false;
                        pushToUndoStack();
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    }
                }

                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            });
        }

        // Utility to convert RGB to Hex
        function rgbToHex(rgb) {
            if (!rgb) return '#000000';
            const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
            return result ? "#" +
                ("0" + parseInt(result[1],10).toString(16)).slice(-2) +
                ("0" + parseInt(result[2],10).toString(16)).slice(-2) +
                ("0" + parseInt(result[3],10).toString(16)).slice(-2) : '#000000';
        }

        // Undo/Redo Functionality
        function pushToUndoStack() {
            const serializer = new XMLSerializer();
            const snapshot = serializer.serializeToString(canvas);
            undoStack.push(snapshot);
            redoStack = []; // Clear redo stack on new action
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length <= 1) return;
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            const previousState = undoStack[undoStack.length - 1];
            canvas.innerHTML = previousState;
            reinitialize();
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop();
            undoStack.push(nextState);
            canvas.innerHTML = nextState;
            reinitialize();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length <= 1;
            redoBtn.disabled = redoStack.length === 0;
        }

        // Reinitialize event listeners after undo/redo
        function reinitialize() {
            selectedElements = [];
            updatePropertiesPanel();
            updateLayersPanel();
            const allElements = canvas.querySelectorAll('*');
            allElements.forEach(el => {
                if (el.tagName !== 'g' && el.tagName !== 'path') {
                    makeDraggable(el);
                }
            });
            removeTransformBox();
        }

        // Initialize with the first action
        pushToUndoStack();

        // Prevent default drag behavior
        window.addEventListener('dragstart', (e) => e.preventDefault());

        // File Upload Handling to display layers/objects
        uploadBtn.addEventListener('click', () => {
            uploadInput.click();
        });

        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(event.target.result, "image/svg+xml");
                const svg = doc.querySelector('svg');
                if (!svg) {
                    alert("Invalid SVG file.");
                    return;
                }
                // Clear current canvas
                canvas.innerHTML = '';
                layers = [];
                addLayer('Layer 1');
                // Import elements
                Array.from(svg.children).forEach(child => {
                    const importedNode = document.importNode(child, true);
                    currentLayer.appendChild(importedNode);
                });
                updateLayersPanel();
                pushToUndoStack();
            };
            reader.readAsText(file);
        });

        // Drag and Drop Upload
        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            canvasContainer.style.background = '#95a5a6';
        });

        canvasContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            canvasContainer.style.background = '#34495e';
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            canvasContainer.style.background = '#34495e';
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'image/svg+xml') {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(event.target.result, "image/svg+xml");
                    const svg = doc.querySelector('svg');
                    if (!svg) {
                        alert("Invalid SVG file.");
                        return;
                    }
                    // Clear current canvas
                    canvas.innerHTML = '';
                    layers = [];
                    addLayer('Layer 1');
                    // Import elements
                    Array.from(svg.children).forEach(child => {
                        const importedNode = document.importNode(child, true);
                        currentLayer.appendChild(importedNode);
                    });
                    updateLayersPanel();
                    pushToUndoStack();
                };
                reader.readAsText(file);
            }
        });

        // Download SVG functionality
        downloadBtn.addEventListener('click', () => {
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(canvas);
            // Add name spaces.
            if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
                source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
            }
            // Add xml declaration
            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            const url = "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(source);
            const downloadLink = document.createElement("a");
            downloadLink.href = url;
            downloadLink.download = "canvas.svg";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        });

        // Zoom functionality
        zoomSlider.addEventListener('input', () => {
            zoomLevel = zoomSlider.value / 100;
            updateCanvasTransform();
        });

        // Ctrl + Scroll to Zoom
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomLevel *= 1.1;
                } else {
                    zoomLevel /= 1.1;
                }
                zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 5);
                zoomSlider.value = zoomLevel * 100;
                updateCanvasTransform();
            }
        });

        // Update canvas transform based on zoom and pan
        function updateCanvasTransform() {
            canvas.setAttribute('transform', `translate(${panX}, ${panY}) scale(${zoomLevel})`);
        }

        // Panning functionality
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        canvasContainer.addEventListener('mousedown', (e) => {
            if (activeTool !== 'select') return;
            if (e.button !== 0) return; // Only left mouse button
            if (e.target.closest('.transform-handle')) return; // Do not pan when interacting with handles
            isPanning = true;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
            canvasContainer.classList.add('grabbing');
        });

        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = (e.clientX - panStart.x) / zoomLevel;
            const dy = (e.clientY - panStart.y) / zoomLevel;
            panX += dx;
            panY += dy;
            updateCanvasTransform();
            panStart.x = e.clientX;
            panStart.y = e.clientY;
        });

        window.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvasContainer.classList.remove('grabbing');
                pushToUndoStack();
            }
        });

        // Brush Tool Implementation
        // Already handled in startDrawing and continueDrawing by differentiating 'brush'

        // Paint Bucket Tool Implementation
        function fillArea(x, y, fillColor) {
            const targetElement = document.elementFromPoint(x, y);
            if (targetElement && (targetElement.tagName === 'rect' || targetElement.tagName === 'circle' || targetElement.tagName === 'ellipse' || targetElement.tagName === 'polygon' || targetElement.tagName === 'path')) {
                targetElement.setAttribute('fill', fillColor);
                pushToUndoStack();
            }
        }

        // Modify selectElement to handle paintBucket tool
        canvas.addEventListener('click', (e) => {
            if (activeTool !== 'paintBucket') return;
            const pt = getMousePosition(e);
            fillArea(e.clientX, e.clientY, colorPicker.value);
        });

        // Transform Box Enhancements: Flip on Scaling
        // Already implemented in addTransformHandleEvents with flip when scaling below zero

        // Prevent default drag behavior
        window.addEventListener('dragstart', (e) => e.preventDefault());

        // Reinitialize event listeners after undo/redo
        function reinitialize() {
            selectedElements = [];
            updatePropertiesPanel();
            updateLayersPanel();
            const allElements = canvas.querySelectorAll('*');
            allElements.forEach(el => {
                if (el.tagName !== 'g' && el.tagName !== 'path') {
                    makeDraggable(el);
                }
            });
            removeTransformBox();
        }

    </script>
</body>
</html>
